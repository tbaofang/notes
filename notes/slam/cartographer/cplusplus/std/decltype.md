类型推导是随着模板和泛型编程的广泛使用而引入的。在非泛型编程中，类型是明确的，而在模板与泛型编程中，类型是不明确的，它取决于传入的参数类型。

decltype与auto还是有一些共同点的，如二者都是通过推导获得的类型来定义另外一个变量，再如二者都是在编译时进行类型推导。不过他们类型推导的方式有所不同，auto是通过初始化表达式推导出类型，而decltype是通过普通表达式的返回值推导出类型。

(1)typeid 与 decltype

(2)decltype的应用
I.decltype 与 using / typedef 连用
II.增加代码的可读性
III.重用匿名类型
IV.decltype 可以适当扩大模板泛型编程的能力。

(3)decltype 推导的四规则

**标记符表达式**(id-expression)的概念

标记符表达式(id-expression)：所有除去关键字和字面量等编译器需要使用的标记以外的程序员自定义的标记(token)都可以是标记符(identifier)， 而单个标记符对应的表达式就是标记符表达式。

还有一点，C++11中对值的类型分类与C++98有所不同。在C++98中，值可分左值与右值。通俗地来讲， 所谓的左值便是含有变量名的数值，所谓的右值就是没有变量名的数值，即为临时变量， 以及包含右值引用。**而在C++11中，就将右值更进一层地分类：分为纯右值与将亡值，纯右值即为没有变量名的数值，将亡值即为右值引用，且左值与将亡值合称为泛左值。**

decltype推导的四规则如下：
（1）如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。此外，如果e是一个被重载的函数，可能会导致编译错误；
（2）否则，假设e的类型是T，如果e是一个将亡值(xvalue), 那么decltype(e)为T&&；
（3）否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&；
（4）否则，假设e的类型是个T， 则decltype(e)为T。